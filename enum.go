package main

import (
	"fmt"
	"os"
	"strings"
	"text/template"
)

func Run(packageName string, typeName string, noPrefix bool, values ...string) error {
	data := make(map[string]interface{})
	data["Package"] = packageName
	data["Items"] = values
	data["Type"] = typeName
	data["Prefix"] = ""
	if !noPrefix {
		data["Prefix"] = typeName
	}
	/*
		fErr, err := os.Create("enum_error.go")
		if err != nil {
			return err
		}
		defer fErr.Close()

		t1 := template.New("t_err")
		t1, err = t1.Parse(fileErrTemplate)
		if err != nil {
			return err
		}
		if err := t1.Execute(fErr, data); err != nil {
			return err
		}
	*/

	fileName := fmt.Sprintf("enum_%s.go", strings.ToLower(typeName))
	f, err := os.Create(fileName)
	if err != nil {
		return err
	}
	defer f.Close()

	t2 := template.New("t_enum")
	t2.Funcs(map[string]interface{}{"Title": strings.Title})
	t2, err = t2.Parse(fileTemplate)
	if err != nil {
		return err
	}
	return t2.Execute(f, data)
}

/*
const fileErrTemplate = `// Code generated by enum. DO NOT EDIT

package {{.Package}}

import "errors"

var ErrEnumUnknown = errors.New("unknown")
`
*/
const fileTemplate = `// Code generated by enum (github.com/mpkondrashin/enum). DO NOT EDIT

package {{.Package}}

import (
    "encoding/json"
	"errors"
    "fmt"
    "strconv"
)

type {{.Type}} int

const (
{{range .Items}}    {{$.Prefix}}{{Title .}} {{$.Type }} = iota
{{end -}})

// String - return string representation for {{.Type}} value
func (v {{.Type}})String() string {
    s, ok := map[{{.Type}}]string {
{{range .Items}}        {{$.Prefix}}{{Title .}}: "{{.}}",
{{end}}    }[v]
    if ok {
        return s
    }
    return "{{.Type}}(" + strconv.FormatInt(int64(v), 10) + ")"
}

// ErrUnknown{{.Type}} - will be returned wrapped when parsing string
// containing unrecognized value.
var ErrUnknown{{.Type}} = errors.New("unknown {{.Type}}")

var map{{.Type}}FromString = map[string]{{.Type}}{
{{range .Items}}    "{{.}}": {{$.Prefix}}{{Title .}},
{{end}}}

// UnmarshalJSON implements the Unmarshaler interface of the json package for {{.Type}}.
func (s *{{.Type}}) UnmarshalJSON(data []byte) error {
    var v string
    if err := json.Unmarshal(data, &v); err != nil {
        return err
    }
    result, ok := map{{.Type}}FromString[v]
    if !ok {
        return fmt.Errorf("%w: %s", ErrUnknown{{.Type}}, v)
    }
    *s = result
    return nil
}

// UnmarshalYAML implements the Unmarshaler interface of the yaml.v3 package for {{.Type}}.
func (s *{{.Type}}) UnmarshalYAML(unmarshal func(interface{}) error) error {
	var v string
	if err := unmarshal(&v); err != nil {
		return err
	}
	result, ok := map{{.Type}}FromString[v]		
	if !ok {
		return fmt.Errorf("%w: %s", ErrUnknown{{.Type}}, v)
	}
	*s = result
	return nil
}
`
