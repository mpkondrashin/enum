package enum

import (
	"errors"
	"fmt"
	"os"
	"strings"
	"text/template"
)

var ErrUnknown = errors.New("unknown")

func Run(packageName string, prefix string, values ...string) error {
	data := make(map[string]interface{})
	data["Package"] = packageName
	data["Items"] = values
	data["Type"] = prefix
	fileName := fmt.Sprintf("%s_enum.go", strings.ToLower(prefix))
	f, err := os.Create(fileName)
	if err != nil {
		return err
	}
	defer f.Close()
	t1 := template.New("t_enum")
	t1.Funcs(map[string]any{"Title": strings.Title})
	t1, err = t1.Parse(fileTemplate)
	if err != nil {
		return err
	}
	return t1.Execute(f, data)
}

const fileTemplate = `// Code generated by enum. DO NOT EDIT

package {{.Package}}

import (
	"encoding/json"
	"errors"
	"fmt"
	"github.com/mpkondrashin/enum"
)

type {{.Type}} int

const (
{{range .Items}}	{{$.Type}}{{Title .}} {{$.Type }} = iota
{{end -}})

func (v {{.Type}})String() string {
	return map[{{.Type}}]string {
{{range .Items}}        {{$.Type}}{{Title .}}: "{{.}}",
{{end}}    }[v]
}

func (s *{{.Type}}) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	result, ok := map[string]{{.Type}}{
{{range .Items}}        "{{.}}": {{$.Type}}{{Title .}},
{{end}}    }[v]
	if !ok {
		return fmt.Errorf("%w: %s", enum.ErrUnknown, v)
	}
	*s = result
	return nil
}
`
